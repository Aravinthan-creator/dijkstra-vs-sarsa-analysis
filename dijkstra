import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib.image as mpimg
import numpy as np
import heapq
import random

def dijkstra(grid, start, end):
    """Dijkstra's algorithm to find the shortest path in a grid"""
    rows, cols = len(grid), len(grid[0])
    dist = [[float('inf')] * cols for _ in range(rows)]
    prev = [[None] * cols for _ in range(rows)]
    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # Right, Down, Left, Up
    
    # Priority queue: (distance, row, col)
    dist[start[0]][start[1]] = 0
    queue = [(0, start[0], start[1])]
    
    while queue:
        d, r, c = heapq.heappop(queue)
        if (r, c) == end:
            break
        if d != dist[r][c]:
            continue
            
        for dr, dc in directions:
            nr, nc = r + dr, c + dc
            if 0 <= nr < rows and 0 <= nc < cols and grid[nr][nc] == 0:
                nd = d + 1
                if nd < dist[nr][nc]:
                    dist[nr][nc] = nd
                    prev[nr][nc] = (r, c)
                    heapq.heappush(queue, (nd, nr, nc))
    
    # Reconstruct path if exists
    if dist[end[0]][end[1]] == float('inf'):
        return None
    
    path = []
    current = end
    while current != start:
        path.append(current)
        current = prev[current[0]][current[1]]
    path.append(start)
    path.reverse()
    
    return path

def generate_maze(size=50, wall_prob=0.25):
    """Generate a random maze ensuring a path exists"""
    start = (0, 0)
    end = (size-1, size-1)
    
    for attempt in range(10):
        # Initialize grid (0 = free, 1 = wall)
        grid = [[0] * size for _ in range(size)]
        
        # Add walls
        for r in range(size):
            for c in range(size):
                if (r, c) == start or (r, c) == end:
                    continue
                if random.random() < wall_prob:
                    grid[r][c] = 1
        
        # Ensure path exists
        path = dijkstra(grid, start, end)
        if path:
            return grid, path
        
        # Reduce wall density if path not found
        wall_prob -= 0.02
    
    # Fallback: create maze with no walls
    grid = [[0] * size for _ in range(size)]
    path = dijkstra(grid, start, end)
    return grid, path

def draw_maze():
    size = 50
    grid, path = generate_maze(size)
    start = (0, 0)
    end = (size-1, size-1)
    
    fig, ax = plt.subplots(figsize=(12, 12))
    
    # Remove axes
    ax.set_xticks([])
    ax.set_yticks([])
    ax.set_xlim(0, size)
    ax.set_ylim(0, size)
    ax.set_aspect('equal')
    ax.invert_yaxis()  # Put (0,0) at top-left
    
    # Draw grid background
    ax.add_patch(patches.Rectangle((0, 0), size, size, facecolor='white'))
    
    # Draw walls
    for r in range(size):
        for c in range(size):
            if grid[r][c] == 1:
                ax.add_patch(patches.Rectangle((c, r), 1, 1, facecolor='black'))
    
    # Draw path (excluding start and end)
    if path:
        for r, c in path[1:-1]:
            ax.add_patch(patches.Rectangle((c + 0.25, r + 0.25), 0.5, 0.5, 
                                         facecolor='yellow', alpha=0.7))
    
    # Draw end point
    er, ec = end
    ax.add_patch(patches.Rectangle((ec, er), 1, 1, facecolor='green', alpha=0.7))
    
    # Draw start point (mouse)
    sr, sc = start
    try:
        # Try to load mouse image
        img = mpimg.imread('mouse.png')
        ax.imshow(img, extent=(sc + 0.1, sc + 0.9, sr + 0.1, sr + 0.9), 
                 zorder=10)
    except FileNotFoundError:
        # Fallback: red circle
        ax.add_patch(patches.Circle((sc + 0.5, sr + 0.5), 0.4, 
                                  color='red', zorder=10))
    
    # Draw grid lines (every 5 units for readability)
    for i in range(0, size+1, 5):
        ax.plot([i, i], [0, size], 'gray', linewidth=0.5, alpha=0.5)
        ax.plot([0, size], [i, i], 'gray', linewidth=0.5, alpha=0.5)
    
    plt.title(f"{size}x{size} Maze with Shortest Path (Dijkstra)")
    plt.tight_layout()
    plt.show()

if __name__ == "__main__":
    draw_maze()
